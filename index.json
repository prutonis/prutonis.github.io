[{"content":"Motivation Being relatively new to the world of blogging, I quickly realized that my recently created website was missing a crucial element – reader feedback. It was evident that I needed to find a way to bridge this gap and encourage readers to voice their opinions and thoughts on my posts.\nThe Search for a Good Commenting Solution: My website is on GitHub and uses Hugo static site generation. So, I needed a commenting solution that fits this setup. Even though Hugo supports Disqus for comments, my experience with it wasn\u0026rsquo;t good due to its slow speed and ads. I found Giscus as an alternative. However, Giscus has its good sides, like using GitHub Discussion and being open-source, but it also has some possible drawbacks. Giscus might not have all the customization and features of other comment systems because it relies on GitHub Discussions, which could lead to to a less satisfactory commenting experience. Also, since it needs a GitHub account for commenting, people who don\u0026rsquo;t want to make a separate account just to comment might not engage as much, especially if they want to stay private or don\u0026rsquo;t know much about GitHub.\nSteps to set up Giscus Create a public respository on GitHub (GH) to hold your site comments, GH guide can be found here. Enable Discussions for the created repository, GH docs. Install Giscus app from GH Marketplace, direct link to install is here. Suggestion: restrict access for Giscus only to specific repository created for comments in step 1. Configure Giscus directly from their site. As result I got this code script tag: \u0026lt;script src=\u0026#34;https://giscus.app/client.js\u0026#34; data-repo=\u0026#34;prutonis/prutonis-comments\u0026#34; data-repo-id=\u0026#34;R_k9DOKFLCjg\u0026#34; data-category=\u0026#34;General\u0026#34; data-category-id=\u0026#34;DLC_kwDOCFLCjs4CYe3b\u0026#34; data-mapping=\u0026#34;pathname\u0026#34; data-strict=\u0026#34;1\u0026#34; data-reactions-enabled=\u0026#34;1\u0026#34; data-emit-metadata=\u0026#34;0\u0026#34; data-input-position=\u0026#34;top\u0026#34; data-theme=\u0026#34;{{ .Site.Params.giscusTheme }}\u0026#34; data-lang=\u0026#34;en\u0026#34; data-loading=\u0026#34;lazy\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34; async\u0026gt; \u0026lt;/script\u0026gt; To avoid direct theme editing, Hugo enables you to customize any theme using Partial templates. So I created a new file layouts/partials/giscus.html with this content: {{- if (eq (.Site.Params.disableComments | default false) false) -}} {{- if (eq (.Params.disableComments | default false) false) -}} \u0026lt;script src=\u0026#34;https://giscus.app/client.js\u0026#34; data-repo=\u0026#34;prutonis/prutonis-comments\u0026#34; data-repo-id=\u0026#34;R_kgDOKFLCjg\u0026#34; data-category=\u0026#34;General\u0026#34; data-category-id=\u0026#34;DIC_kwDOKFLCjs4CYe3b\u0026#34; data-mapping=\u0026#34;pathname\u0026#34; data-strict=\u0026#34;1\u0026#34; data-reactions-enabled=\u0026#34;1\u0026#34; data-emit-metadata=\u0026#34;0\u0026#34; data-input-position=\u0026#34;top\u0026#34; data-theme=\u0026#34;{{ .Site.Params.giscusTheme }}\u0026#34; data-lang=\u0026#34;en\u0026#34; data-loading=\u0026#34;lazy\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34; async\u0026gt; \u0026lt;/script\u0026gt; {{- end -}} {{- end -}} I\u0026rsquo;m using the PaperMod theme, so I duplicated themes/PaperMod/layouts/partials/comments.html to layouts/partials/comments.html and made edits to include the newly created partial from step 6. {{- /* Comments area start */ -}} {{ partial \u0026#34;giscus\u0026#34; . }} {{- /* Comments area end */ -}} Hugo config.yml setup: params: ... comments: true giscusTheme: preferred_color_scheme disableComments: false ... The result: Wrap-Up Thanks to GitHub, I am able to both host my website and facilitate comments for it. This free feature provided by GitHub is truly invaluable. In the future, I intend to explore the possibility of implementing a self-hosted commenting system like Commento or StaticMan, and I will be sharing my experience on the blog.\nP.S. Special thanks to Justin Bird for the insightful blog post on setting up Giscus.\n","permalink":"https://morosanu.io/posts/adding-comments-to-my-blog/","summary":"Motivation Being relatively new to the world of blogging, I quickly realized that my recently created website was missing a crucial element – reader feedback. It was evident that I needed to find a way to bridge this gap and encourage readers to voice their opinions and thoughts on my posts.\nThe Search for a Good Commenting Solution: My website is on GitHub and uses Hugo static site generation. So, I needed a commenting solution that fits this setup.","title":"Adding Comments to My Blog"},{"content":"Introduction Being mainly a Java programmer, I decided however to expand my area of knowledge and the fates fell on the Go language. And the best way to learn is to apply, to practice what you learn! I usually prefer to do this by implementing a game or a tool that has some use.\nSo this time it\u0026rsquo;s a game - Wordle, but implemented as a Telegram Bot.\nEnvironment To run Go code, you need to install Go on your local computer. In my case, I\u0026rsquo;m using Windows 10, so I installed the latest version of Go, which is currently 1.20.5, from their website. For development, I use Visual Studio Code as my IDE.\nTelegram Bot I created my Telegram Bot using The Botfather. For more information check the official documentation available here. To create a bot, you need to communicate to The Botfather and request a new bot with the command\n/newbot Wordle Game The Wordle Game involves guessing a five-letter word chosen by the computer. You have six attempts to guess the word, with feedback given for each guess in the form of colored tiles indicating when letters match or occupy the correct position. These tiles indicate whether the letters match or occupy the correct position. However, due to the nature of Telegram, we can only provide feedback to the user using text characters, such as letters and symbols:\nBold letter - indicates the letter is in the correct position. Italic letter - indicates the letter is present but not in the correct position. # - indicates the letter is not present in the word. Implementation You can find the game implementation in this GitHub repository https://github.com/prutonis/wordlebot. Some key points to mention are that I used yanzay\u0026rsquo;s Bot library to communicate with Telegram Bot API. Also I used zap library for logging, the viper for storing and reading configuration files, and GoDtoEnv library for reading .env file where the Bot Token is stored.\nThe entry point of the program is the WordleBot() function in pkg/wordlebot/wbot.go which is called from main.go:\nfunc WordleBot() { Chats = make(chats) Bot = tbot.New(Token) App.client = Bot.Client() Bot.HandleMessage(\u0026#34;/help\u0026#34;, App.helpHandler) Bot.HandleMessage(\u0026#34;/start\u0026#34;, App.startHandler) Bot.HandleMessage(\u0026#34;/giveup\u0026#34;, App.giveUpHandler) Bot.HandleMessage(\u0026#34;/lang\u0026#34;, App.languageHandler) Bot.HandleMessage(\u0026#34;^.{5}$\u0026#34;, App.messagesHandler) Bot.HandleCallback(App.callbackHandler) log.Fatal(Bot.Start()) } Play with Docker If you have access to a Docker instance, you can run the bot within seconds by following these instructions:\nClone the repository $ git clone https://github.com/prutonis/wordlebot Navigate to the wordlebot directory and set your Bot token in the .env file: $ cd wordlebot $ echo TBOT_TOKEN=4839574812:AAFD39kkdpWt3ywyRZergyOLMaJhac60qc \u0026gt; .env Build the Docker image $ docker build -t wordlebot . Start a Docker container from the created image: $ docker run --name wordle_game --rm -d -t wordlebot Now, you can enjoy the game. Simply open your bot in Telegram and type /start or /help to begin.\nFeatures The help menu of the game:\nYou can choose between English and Romanian languages: An example of gameplay: You cand try the game with the Wordle bot instance: Wordle Telegram Bot.\n","permalink":"https://morosanu.io/posts/wordle-game-telegram-bot/","summary":"Introduction Being mainly a Java programmer, I decided however to expand my area of knowledge and the fates fell on the Go language. And the best way to learn is to apply, to practice what you learn! I usually prefer to do this by implementing a game or a tool that has some use.\nSo this time it\u0026rsquo;s a game - Wordle, but implemented as a Telegram Bot.\nEnvironment To run Go code, you need to install Go on your local computer.","title":"Wordle: A Telegram Bot Game in Go"},{"content":"Introduction Hello, world! It\u0026rsquo;s a pleasure to embark on this blogging journey and share my experiences as a software engineer with all of you. With over 15 years of expertise in the realms of C, Python, and Java, my journey has primarily revolved around backend development. However, I have recently set my sights on the captivating realm of modern frontend technologies. In this blog post, I\u0026rsquo;ll take you through my transition, the challenges I\u0026rsquo;ve encountered, and the excitement of expanding my skill set to include the modern frontend stack.\nEmbracing the Backend Throughout my career, I\u0026rsquo;ve been deeply engrossed in the backend universe. I\u0026rsquo;ve had the privilege of working on intricate systems, optimizing algorithms, and designing robust architectures. The world of C, Python, and Java has been my home, allowing me to develop a strong foundation in building scalable and efficient backend solutions. From crafting microservices to wrangling massive data sets, I\u0026rsquo;ve relished the opportunities that have come my way.\nA Shift in Perspective As the technological landscape evolved and user expectations soared, I found myself intrigued by the user-facing aspects of software development. Witnessing the rise of rich web applications and the power of interactive interfaces, I felt compelled to delve into the modern frontend stack. While my core expertise lay in backend technologies, I recognized the need to adapt and embrace the ever-changing demands of the software industry.\nThe Fascinating World of Frontend My journey into the world of frontend development began with curiosity and a thirst for knowledge. The intricacies of HTML, CSS, and JavaScript started to captivate me, and I soon realized the immense possibilities they offered. The modern frontend stack, with frameworks like React, Angular, and Vue.js, presented an ocean of opportunities to create dynamic, responsive, and engaging user interfaces.\nThe Learning Curve Transitioning from a backend-focused software engineer to a well-rounded full-stack developer came with its fair share of challenges. Concepts like state management, component-based architecture, and responsive design introduced new paradigms that required a shift in my mindset. However, armed with determination and a willingness to learn, I immersed myself in online tutorials, documentation, and engaging with the vibrant developer community.\nFinal Thoughts In this introductory blog post, I\u0026rsquo;ve shared my background as a software engineer with a strong backend focus and my recent foray into the modern frontend stack. As I continue to grow and learn, I\u0026rsquo;m eager to embrace the challenges and opportunities that lie ahead. Stay tuned for more exciting content as I share my insights, tips, and experiences in this ever-evolving world of software engineering.\nThank you for joining me on this journey, and remember, with determination and an eagerness to adapt, the possibilities are endless!\n","permalink":"https://morosanu.io/posts/hello-world/","summary":"Introduction Hello, world! It\u0026rsquo;s a pleasure to embark on this blogging journey and share my experiences as a software engineer with all of you. With over 15 years of expertise in the realms of C, Python, and Java, my journey has primarily revolved around backend development. However, I have recently set my sights on the captivating realm of modern frontend technologies. In this blog post, I\u0026rsquo;ll take you through my transition, the challenges I\u0026rsquo;ve encountered, and the excitement of expanding my skill set to include the modern frontend stack.","title":"Hello World! A Glimpse into the World of a Seasoned Software Engineer"}]